

###### 黑马点评

##### 环境配置-Mac:



### 基于 Redis 的短信验证功能的实现

##### 1.生成 CODE 并将 CODE 存入 Redis 中 ：

> - 校验手机号格式是否正确
>
> - 利用随机数方法生成一条 指定位数x 位的验证码
>
> - 将验证码以 string 类型的方式插入 Redis 中
>
>   KEY ：业务名+phone，VALUE：CODE，这样每一个用户所对应的 KEY 都唯一
>
> - 将生成 CODE 的结果返回给前端 

```java
 public Result sendCode(String phone, HttpSession session) {
        //TODO 1
        if (RegexUtils.isPhoneInvalid(phone)){
            return Result.fail("手机号格式错误");
        }
        //TODO 2
        String code = RandomUtil.randomNumbers(6);
        //TODO 3
        stringRedisTemplate.opsForValue()
          .set(LOGIN_CODE_KEY+phone,code,LOGIN_CODE_TTL, TimeUnit.MINUTES);

        log.debug("发送短信验证码成功{"+code+"}");
        //TODO 4
        return Result.ok();
    }
```

##### 2.校验用户信息以及用户输入的验证码是否匹配

> - 校验手机号格式是否正确
>
> - 从 Redis 中获取 系统生成的CODE
>
> - 从前端返回的结果中获取 用户输入CODE
>
> - 校验 CODE 是否匹配
>
> - 根据 phone 从数据库中获取用户信息，如果 数据库查询结果为空 则该用户未注册，自动创建用户
>
> - 使用 UUID 随机生成一个 TOKEN
>
> - 防止隐私泄露使用 UserDTO 来截取 User中的部分信息此功能通过BeanUtil.copyProperties方法实现
>
> - 将 TOKEN 以及 UserDTO 以Hash类型存入 redis中，为了减少频繁与 redis 交互，使用BeanUtil.breanToMap方法将 UserDTO 转化为 Map 类型
>
>   ###### 此处有坑：JSON序列化导致Long类型被搞成Integer经典巨坑
>
>   我们采取在 BeanUtil.breanToMap 中设置以下方法将 VALUE 的类型转化为string存储
>
>   setFieldValueEditor((fieldName,fieldValue)->fieldValue.toString()))
>
> - 在 Redis 中设置 TOOKEN 有效期
>
> - 将 TOKEN 返回给前端

```java
 public Result login(LoginFormDTO loginForm,HttpSession session) {
        String phone = loginForm.getPhone();
        if(RegexUtils.isPhoneInvalid(phone)){
            return Result.fail("手机号格式错误");
        }
        Object cacheCode =
          stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY+phone);
        String code = loginForm.getCode();
        if(cacheCode == null || !cacheCode.toString().equals(code)){
            return Result.fail("验证码错误");
        }
        //根据手机号查询用户
        User user = query().eq("phone",phone).one();
        if(user == null){
            user = createUserWith(phone);
        }
        String token = UUID.randomUUID().toString(true);

        UserDTO userDTO = BeanUtil.copyProperties(user,UserDTO.class);
   			/**********************相当重要的一步操作**********************************/
        Map<String, Object> usermap = BeanUtil.beanToMap(userDTO,new HashMap<>(), 
                CopyOptions.create().setIgnoreNullValue(true)
                .setFieldValueEditor
                        ((fieldName,fieldValue)->fieldValue.toString()));
        stringRedisTemplate.opsForHash()
                .putAll(LOGIN_USER_KEY+token,usermap);
        stringRedisTemplate
                .expire(LOGIN_USER_KEY+token,LOGIN_USER_TTL,TimeUnit.MINUTES);
        return Result.ok(token);
    }

private User createUserWith(String phone) {
        User user = new User();
        user.setPhone(phone);
        user.setNickName(USER_NICK_NAME_PREFIX+RandomUtil.randomString(10));
        save(user);
        return user;
    }
```

##### 3.根据用户的访问来延长 TOKEN 有效期

> 通过设置两层拦截器来实现
